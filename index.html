<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Advanced PLY Viewer & Noise-Based Generator</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body {
            font-family: 'Inter', sans-serif;
            overflow: hidden; /* Prevent scrollbars from appearing */
        }
        #loader {
            transition: opacity 0.5s;
        }
        /* Custom scrollbar for better aesthetics */
        ::-webkit-scrollbar {
            width: 8px;
        }
        ::-webkit-scrollbar-track {
            background: #2d3748;
        }
        ::-webkit-scrollbar-thumb {
            background: #4a5568;
            border-radius: 4px;
        }
        ::-webkit-scrollbar-thumb:hover {
            background: #718096;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
</head>
<body class="bg-gray-900 text-white">

    <!-- 3D Canvas Container -->
    <div id="canvas-container" class="absolute top-0 left-0 w-full h-full"></div>

    <!-- UI Controls Panel -->
    <div class="absolute top-4 left-4 bg-gray-800 bg-opacity-80 backdrop-blur-sm p-6 rounded-lg shadow-2xl w-full max-w-sm max-h-[calc(100vh-2rem)] overflow-y-auto">
        <div class="space-y-6">
            <!-- Header -->
            <div>
                <h1 class="text-2xl font-bold text-cyan-400">3D PLY Studio</h1>
                <p class="text-gray-400 mt-1">Load PLY files or generate terrain.</p>
            </div>

            <!-- File Loader Section -->
            <div class="space-y-3">
                <h2 class="text-lg font-semibold border-b-2 border-gray-700 pb-2">Load Model</h2>
                <p class="text-sm text-gray-400">Select a .PLY file to view.</p>
                <input type="file" id="file-input" accept=".ply" class="block w-full text-sm text-gray-300
                    file:mr-4 file:py-2 file:px-4
                    file:rounded-md file:border-0
                    file:text-sm file:font-semibold
                    file:bg-cyan-500 file:text-white
                    hover:file:bg-cyan-600 transition-colors cursor-pointer"/>
            </div>

            <!-- Noise Based Generation Section -->
            <div class="space-y-4">
                <h2 class="text-lg font-semibold border-b-2 border-gray-700 pb-2">Generate Terrain</h2>
                
                <!-- Terrain Size -->
                <div class="grid grid-cols-2 gap-4">
                    <div>
                        <label for="terrain-width" class="block text-sm font-medium text-gray-300">Width</label>
                        <input type="number" id="terrain-width" value="100" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm focus:ring-cyan-500 focus:border-cyan-500 sm:text-sm p-2">
                    </div>
                    <div>
                        <label for="terrain-height" class="block text-sm font-medium text-gray-300">Height</label>
                        <input type="number" id="terrain-height" value="100" class="mt-1 block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm focus:ring-cyan-500 focus:border-cyan-500 sm:text-sm p-2">
                    </div>
                </div>

                <!-- Seed -->
                <div>
                    <label for="terrain-seed" class="block text-sm font-medium text-gray-300">Seed</label>
                    <div class="flex space-x-2 mt-1">
                        <input type="text" id="terrain-seed" class="block w-full bg-gray-700 border-gray-600 rounded-md shadow-sm focus:ring-cyan-500 focus:border-cyan-500 sm:text-sm p-2">
                        <button id="randomize-seed-btn" class="px-3 py-2 bg-gray-600 hover:bg-gray-500 rounded-md text-sm font-semibold">Randomize</button>
                    </div>
                </div>

                <!-- Noise Scale -->
                <div>
                    <label for="noise-scale" class="block text-sm font-medium text-gray-300">Noise Scale: <span id="noise-scale-value">0.1</span></label>
                    <input type="range" id="noise-scale" min="0.01" max="0.5" step="0.01" value="0.1" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                </div>
                
                <!-- Terrain Amplitude -->
                 <div>
                    <label for="terrain-amplitude" class="block text-sm font-medium text-gray-300">Amplitude: <span id="terrain-amplitude-value">15</span></label>
                    <input type="range" id="terrain-amplitude" min="1" max="50" step="1" value="15" class="w-full h-2 bg-gray-700 rounded-lg appearance-none cursor-pointer">
                </div>

                <!-- Action Buttons -->
                <div class="flex space-x-4">
                    <button id="generate-btn" class="flex-1 bg-green-500 hover:bg-green-600 text-white font-bold py-2 px-4 rounded-md transition-transform transform hover:scale-105">
                        Generate
                    </button>
                    <button id="download-btn" class="flex-1 bg-blue-500 hover:bg-blue-600 text-white font-bold py-2 px-4 rounded-md transition-transform transform hover:scale-105 disabled:bg-gray-600 disabled:cursor-not-allowed" disabled>
                        Download .PLY
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Loader Overlay -->
    <div id="loader" class="absolute inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center hidden z-50">
        <div class="flex flex-col items-center">
            <div class="animate-spin rounded-full h-16 w-16 border-t-4 border-b-4 border-cyan-400"></div>
            <p class="mt-4 text-lg">Processing...</p>
        </div>
    </div>
    
    <!-- Message Box -->
    <div id="message-box" class="absolute bottom-4 right-4 bg-gray-800 text-white py-2 px-4 rounded-lg shadow-lg opacity-0 transition-opacity duration-500">
        Message
    </div>

    <!-- Three.js and dependencies -->
    <script type="importmap">
        {
            "imports": {
                "three": "https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.module.js",
                "three/addons/": "https://cdn.jsdelivr.net/npm/three@0.160.0/examples/jsm/"
            }
        }
    </script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { PLYLoader } from 'three/addons/loaders/PLYLoader.js';
        import { createNoise2D } from 'https://cdn.jsdelivr.net/npm/simplex-noise@4.0.1/dist/esm/simplex-noise.js';

        // --- DOM Element References ---
        const canvasContainer = document.getElementById('canvas-container');
        const fileInput = document.getElementById('file-input');
        const generateBtn = document.getElementById('generate-btn');
        const downloadBtn = document.getElementById('download-btn');
        const loader = document.getElementById('loader');
        const messageBox = document.getElementById('message-box');
        const seedInput = document.getElementById('terrain-seed');
        const randomizeSeedBtn = document.getElementById('randomize-seed-btn');
        
        // --- Global Variables ---
        let scene, camera, renderer, controls, currentObject, wireframeObject;

        // --- Seeded PRNG (Pseudo-Random Number Generator) ---
        function createAlea(seed) {
            const s = 2147483647;
            const a = 16807;
            let state = seed ? 
                seed.toString().split('').reduce((acc, char) => acc + char.charCodeAt(0), 1) % s : 
                Math.floor(Math.random() * s);
            
            return function() {
                state = (state * a) % s;
                return (state - 1) / (s - 1);
            };
        }
        
        // --- Initialization ---
        function init() {
            // Scene
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0x000000); // Dark background for contrast
            scene.fog = new THREE.Fog(0x000000, 50, 250); // Atmospheric fog

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(50, 50, 50);

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio);
            canvasContainer.appendChild(renderer.domElement);

            // Lighting (Stylized)
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
            scene.add(ambientLight);
            const pointLight1 = new THREE.PointLight(0xff00ff, 1, 300); // Magenta
            pointLight1.position.set(50, 50, 50);
            scene.add(pointLight1);
            const pointLight2 = new THREE.PointLight(0x00ffff, 1, 300); // Cyan
            pointLight2.position.set(-50, -50, 50);
            scene.add(pointLight2);

            // Controls
            controls = new OrbitControls(camera, renderer.domElement);
            controls.enableDamping = true;
            controls.dampingFactor = 0.05;
            controls.screenSpacePanning = false;
            controls.minDistance = 10;
            controls.maxDistance = 200; // Reduced max distance for a tighter feel
            controls.maxPolarAngle = Math.PI; // Allow full rotation

            // Event Listeners
            window.addEventListener('resize', onWindowResize, false);
            fileInput.addEventListener('change', handleFileLoad, false);
            generateBtn.addEventListener('click', handleGeneration, false);
            downloadBtn.addEventListener('click', handleDownload, false);
            randomizeSeedBtn.addEventListener('click', generateRandomSeed, false);

            // Slider value displays
            const noiseScaleSlider = document.getElementById('noise-scale');
            const noiseScaleValue = document.getElementById('noise-scale-value');
            noiseScaleSlider.addEventListener('input', () => noiseScaleValue.textContent = noiseScaleSlider.value);
            
            const amplitudeSlider = document.getElementById('terrain-amplitude');
            const amplitudeValue = document.getElementById('terrain-amplitude-value');
            amplitudeSlider.addEventListener('input', () => amplitudeValue.textContent = amplitudeSlider.value);

            generateRandomSeed();
            animate();
            showMessage("Style updated! Generate a new terrain.", "info");
        }

        // --- Core Functions ---

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            renderer.render(scene, camera);
        }

        function clearScene() {
            if (currentObject) {
                scene.remove(currentObject);
                currentObject.geometry.dispose();
                currentObject.material.dispose();
                currentObject = null;
            }
             if (wireframeObject) {
                scene.remove(wireframeObject);
                wireframeObject.geometry.dispose();
                wireframeObject.material.dispose();
                wireframeObject = null;
            }
            downloadBtn.disabled = true;
        }
        
        function centerAndFocus(object) {
            const box = new THREE.Box3().setFromObject(object);
            const center = box.getCenter(new THREE.Vector3());
            const size = box.getSize(new THREE.Vector3());
            const maxDim = Math.max(size.x, size.y, size.z);
            const fov = camera.fov * (Math.PI / 180);
            let cameraZ = Math.abs(maxDim / 2 / Math.tan(fov / 2));
            cameraZ *= 1.5;

            controls.reset();
            controls.target.copy(center);
            camera.position.copy(center);
            camera.position.z += cameraZ;
            camera.lookAt(center);
            controls.update();
        }

        function generateRandomSeed() {
            seedInput.value = Math.random().toString(36).substring(2, 10).toUpperCase();
        }

        // --- Event Handlers ---

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function handleFileLoad(event) {
            const file = event.target.files[0];
            if (!file) return;

            showLoader(true);
            const reader = new FileReader();
            reader.onload = (e) => {
                const loader = new PLYLoader();
                try {
                    const geometry = loader.parse(e.target.result);
                    geometry.computeVertexNormals();
                    
                    // Use Phong material for loaded objects too for consistency
                    const material = new THREE.MeshPhongMaterial({ 
                        vertexColors: geometry.hasAttribute('color'),
                        color: geometry.hasAttribute('color') ? 0xffffff : 0xaaaaaa,
                        flatShading: true, // Classic low-poly look
                        shininess: 30
                    });

                    clearScene();
                    currentObject = new THREE.Mesh(geometry, material);
                    scene.add(currentObject);
                    centerAndFocus(currentObject);
                    showMessage(`Loaded "${file.name}" successfully.`, "success");
                } catch (error) {
                    console.error("Error parsing PLY file:", error);
                    showMessage("Error: Could not parse the PLY file.", "error");
                } finally {
                    showLoader(false);
                    fileInput.value = '';
                }
            };
            reader.readAsArrayBuffer(file);
        }

        function handleGeneration() {
            showLoader(true);
            
            setTimeout(() => {
                try {
                    clearScene();

                    const width = parseInt(document.getElementById('terrain-width').value) || 100;
                    const height = parseInt(document.getElementById('terrain-height').value) || 100;
                    const noiseScale = parseFloat(document.getElementById('noise-scale').value) || 0.1;
                    const amplitude = parseFloat(document.getElementById('terrain-amplitude').value) || 15;
                    const seed = seedInput.value;

                    const randomFunc = createAlea(seed);
                    const noise2D = createNoise2D(randomFunc);

                    const geometry = new THREE.PlaneGeometry(width, height, width - 1, height - 1);
                    const positionAttribute = geometry.getAttribute('position');
                    const colors = [];
                    const color = new THREE.Color();
                    const colorA = new THREE.Color(0xff00ff); // Magenta
                    const colorB = new THREE.Color(0x00ffff); // Cyan

                    for (let i = 0; i < positionAttribute.count; i++) {
                        const x = positionAttribute.getX(i);
                        const y = positionAttribute.getY(i);
                        const noiseVal = noise2D(x * noiseScale, y * noiseScale);
                        positionAttribute.setZ(i, noiseVal * amplitude);

                        // Stylized color gradient based on height
                        const normalizedHeight = (noiseVal + 1) / 2;
                        color.lerpColors(colorA, colorB, normalizedHeight);
                        colors.push(color.r, color.g, color.b);
                    }
                    
                    geometry.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
                    geometry.computeVertexNormals();

                    // Main terrain material
                    const material = new THREE.MeshPhongMaterial({ 
                        vertexColors: true, 
                        shininess: 50,
                        flatShading: true // Key for the low-poly look
                    });
                    currentObject = new THREE.Mesh(geometry, material);
                    currentObject.rotation.x = -Math.PI / 2;
                    scene.add(currentObject);

                    // Wireframe overlay
                    const wireframeMaterial = new THREE.MeshBasicMaterial({
                        color: 0x000000,
                        wireframe: true,
                        transparent: true,
                        opacity: 0.1
                    });
                    wireframeObject = new THREE.Mesh(geometry, wireframeMaterial);
                    wireframeObject.rotation.x = -Math.PI / 2;
                    scene.add(wireframeObject);


                    centerAndFocus(currentObject);
                    downloadBtn.disabled = false;
                    showMessage(`Generated terrain with seed: ${seed}`, "success");

                } catch (error) {
                    console.error("Error generating terrain:", error);
                    showMessage("An error occurred during generation.", "error");
                } finally {
                    showLoader(false);
                }
            }, 50);
        }

        function handleDownload() {
            if (!currentObject) {
                showMessage("No object to download.", "error");
                return;
            }
            
            showLoader(true);
            setTimeout(() => {
                try {
                    const geometry = currentObject.geometry;
                    const vertices = geometry.getAttribute('position');
                    const colors = geometry.getAttribute('color');
                    const indices = geometry.getIndex();

                    let plyData = "ply\n";
                    plyData += "format ascii 1.0\n";
                    plyData += `element vertex ${vertices.count}\n`;
                    plyData += "property float x\n";
                    plyData += "property float y\n";
                    plyData += "property float z\n";
                    if (colors) {
                        plyData += "property uchar red\n";
                        plyData += "property uchar green\n";
                        plyData += "property uchar blue\n";
                    }
                    plyData += `element face ${indices.count / 3}\n`;
                    plyData += "property list uchar int vertex_indices\n";
                    plyData += "end_header\n";
                    
                    const tempVertex = new THREE.Vector3();
                    for (let i = 0; i < vertices.count; i++) {
                        tempVertex.fromBufferAttribute(vertices, i);
                        tempVertex.applyMatrix4(currentObject.matrixWorld);

                        plyData += `${tempVertex.x} ${tempVertex.y} ${tempVertex.z}`;
                        if (colors) {
                            const r = Math.floor(colors.getX(i) * 255);
                            const g = Math.floor(colors.getY(i) * 255);
                            const b = Math.floor(colors.getZ(i) * 255);
                            plyData += ` ${r} ${g} ${b}`;
                        }
                        plyData += "\n";
                    }

                    for (let i = 0; i < indices.count; i += 3) {
                        const i1 = indices.getX(i);
                        const i2 = indices.getX(i + 1);
                        const i3 = indices.getX(i + 2);
                        plyData += `3 ${i1} ${i2} ${i3}\n`;
                    }

                    const blob = new Blob([plyData], { type: 'text/plain' });
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = `generated_terrain_${Date.now()}.ply`;
                    link.click();
                    URL.revokeObjectURL(link.href);
                    showMessage("PLY file exported successfully.", "success");

                } catch (error) {
                    console.error("Error exporting PLY:", error);
                    showMessage("Failed to export PLY file.", "error");
                } finally {
                    showLoader(false);
                }
            }, 50);
        }

        // --- UI Utility Functions ---

        function showLoader(show) {
            if (show) {
                loader.classList.remove('hidden');
            } else {
                loader.classList.add('hidden');
            }
        }

        let messageTimeout;
        function showMessage(text, type = 'info') {
            messageBox.textContent = text;
            messageBox.classList.remove('bg-gray-800', 'bg-green-600', 'bg-red-600');
            
            if (type === 'success') {
                messageBox.classList.add('bg-green-600');
            } else if (type === 'error') {
                messageBox.classList.add('bg-red-600');
            } else {
                messageBox.classList.add('bg-gray-800');
            }

            messageBox.classList.remove('opacity-0');
            
            clearTimeout(messageTimeout);
            messageTimeout = setTimeout(() => {
                messageBox.classList.add('opacity-0');
            }, 4000);
        }

        // --- Start the application ---
        init();
    </script>
</body>
</html>
